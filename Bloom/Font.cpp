/***********************************************
 * File: Font.cpp
 *
 * Author: LYG
 * Date: Ê®Ò»ÔÂ 2018
 *
 * Purpose:
 *
 * 
 **********************************************/

#include "Font.h"
#include "ResourceManager.h"
#include "Scene.h"
#include "Log.h"
#include "Texture.h"
#include "RenderSystem.h"
#include "GameDef.h"
#include FT_BITMAP_H

#pragma comment(lib, "freetype.lib")

// this code is copy from freetype sample
namespace OutLine
{
#ifdef _MSC_VER
#define MIN __min
#define MAX __max
#else
#define MIN std::min
#define MAX std::max
#endif
	// Define some fixed size types.
	typedef unsigned char uint8;
	typedef unsigned short uint16;
	typedef unsigned int uint32;

	// Try to figure out what endian this machine is using. Note that the test
	// below might fail for cross compilation; additionally, multi-byte
	// characters are implementation-defined in C preprocessors.

#if (('1234' >> 24) == '1')
#elif (('4321' >> 24) == '1')
#define BIG_ENDIAN
#else
#error "Couldn't determine the endianness!"
#endif
	// A simple 16-bit pixel.
	struct Pixel16
	{
		Pixel16()
		{
			l = 0;
			a = 255;
		}
		Pixel16(uint8 li, uint8 ai = 255)
		{
			l = li;
			a = ai;
		}
#ifdef BIG_ENDIAN
		uint8 a, l;
#else // BIG_ENDIAN
		uint8 l, a;
#endif // BIG_ENDIAN
	};

	struct Vec2
	{
		Vec2() { }
		Vec2(float a, float b)
			: x(a), y(b) { }

		float x, y;
	};

	struct Rect
	{
		Rect() { }
		Rect(float left, float top, float right, float bottom)
			: xmin(left), xmax(right), ymin(top), ymax(bottom) { }

		void Include(const Vec2 &r)
		{
			xmin = MIN(xmin, r.x);
			ymin = MIN(ymin, r.y);
			xmax = MAX(xmax, r.x);
			ymax = MAX(ymax, r.y);
		}

		float Width() const { return xmax - xmin + 1; }
		float Height() const { return ymax - ymin + 1; }

		float xmin, xmax, ymin, ymax;
	};

	// A horizontal pixel span generated by the FreeType renderer.
	struct Span
	{
		Span() { }
		Span(int _x, int _y, int _width, int _coverage)
			: x(_x), y(_y), width(_width), coverage(_coverage) { }

		int x, y, width, coverage;
	};

	typedef std::vector<Span> Spans;
	// Each time the renderer calls us back we just push another span entry on
	// our list.

	void RasterCallback(const int y,
		const int count,
		const FT_Span * const spans,
		void * const user)
	{
		Spans *sptr = (Spans *)user;
		for (int i = 0; i < count; ++i)
			sptr->push_back(Span(spans[i].x, y, spans[i].len, spans[i].coverage));
	}


	// Set up the raster parameters and render the outline.

	void RenderSpans(FT_Library &library,
		FT_Outline * const outline,
		Spans *spans)
	{
		FT_Raster_Params params;
		memset(&params, 0, sizeof(params));
		params.flags = FT_RASTER_FLAG_AA | FT_RASTER_FLAG_DIRECT;
		params.gray_spans = RasterCallback;
		params.user = spans;

		FT_Outline_Render(library, outline, &params);
	}
};
 //-----------------------------------------------------------------------

int Font::TextureUsed::TextureIndex = 0;
Font::TextureUsed::TextureUsed()
{
	XOffset = 0;
	YOffset = 0;
	MaxRowHeight = 0;
	TextureBuffer = nullptr;
	BufferLen = 0;
	Tex = nullptr;

	memset(FontTextureName, 0, sizeof(FontTextureName));
	sprintf_s(FontTextureName, sizeof(FontTextureName), "Font_Texture_%d", TextureIndex++);
}
Font::TextureUsed::~TextureUsed()
{
	// Not need to destroy Tex, which will be done in TextureManager.
	SAFE_DELETE_ARRAY(TextureBuffer);
}

bool Font::TextureUsed::AddText(TextInfo& TI, FT_Bitmap& BitMap, bool IsL8/* = true*/)
{
	if (Tex == nullptr)
	{
		TextureManager* TM = Scene::GetCurrentScene()->GetTextureManager();
		RenderSystemD3D11* RS = Scene::GetCurrentScene()->GetRenderSystem();
		Tex = TM->CreateTexture(FontTextureName, RS->GetD3d11Device(), FONT_IMAGE_SIZE, FONT_IMAGE_SIZE, DXGI_FORMAT_R8G8_UNORM, 1, true);
		BufferLen = FONT_IMAGE_SIZE * FONT_IMAGE_SIZE * 2;
		TextureBuffer = new unsigned char[BufferLen];
		memset(TextureBuffer, 0, BufferLen);
	}
	else
	{
		// Detect if Tex is full
		if (YOffset + BitMap.rows >= FONT_IMAGE_SIZE)
		{
			// image is full
			// don't need this buffer now, release.
			SAFE_DELETE_ARRAY(TextureBuffer);
			return false;
		}
	}
	if (XOffset + BitMap.width >= FONT_IMAGE_SIZE)
	{
		// next row
		XOffset = 0;
		YOffset += MaxRowHeight;
		MaxRowHeight = BitMap.rows;
		if (YOffset + BitMap.rows >= FONT_IMAGE_SIZE)
		{
			// image is full
			// don't need this buffer now, release.
			SAFE_DELETE_ARRAY(TextureBuffer);
			return false;
		}
	}
	// 
	TI.UVLeftTop = Vector2(float(XOffset) / float(FONT_IMAGE_SIZE), float(YOffset) / float(FONT_IMAGE_SIZE));
	TI.UVRightBottom = Vector2(float(XOffset + BitMap.width) / float(FONT_IMAGE_SIZE), float(YOffset + BitMap.rows) / float(FONT_IMAGE_SIZE));
	TI.Tex = Tex;
	// write font content to the buffer and blit the buffer to the D3DTexture
	int TexIndex = 0;
	for (int i = 0; i < (int)BitMap.rows; i++)
	{
		for (int j = 0; j < (int)BitMap.width; j++)
		{
			if (IsL8)
			{
				unsigned char c = BitMap.buffer[TexIndex++];
				int BufferPos = ((YOffset + i) * FONT_IMAGE_SIZE + XOffset + j) * 2;
				TextureBuffer[BufferPos++] = c;
				TextureBuffer[BufferPos] = c;
			}
			else
			{
				unsigned char c = BitMap.buffer[TexIndex * 2 + 0];
				unsigned char a = BitMap.buffer[TexIndex * 2 + 1];
				TexIndex++;
				int BufferPos = ((YOffset + i) * FONT_IMAGE_SIZE + XOffset + j) * 2;
				TextureBuffer[BufferPos++] = c;
				TextureBuffer[BufferPos] = a;
			}
		}
	}
	TI.Tex->BlitToTexture(TextureBuffer, BufferLen);
	XOffset += BitMap.width;
	MaxRowHeight = MaxRowHeight < (int)BitMap.rows ? BitMap.rows : MaxRowHeight;
	return true;
}

 //-----------------------------------------------------------------------
Font::Font()
{
	mFTLibrary = nullptr;
	mFTFace = nullptr;
	mFTStroker = nullptr;
	mFontType = MFMengYuan;
	mFontSize = 0;
	mFontStyle = FSNormal;
	mOutlineWidth = 0;
	mBoldWidth = 0;
	mRotateDegree = 0.0f;
}

Font::~Font()
{
	for each(TextureUsed* TU in mTextureUesedArray)
	{
		SAFE_DELETE(TU);
	}
	mTextureUesedArray.clear();
	std::map<unsigned long, TextInfo*>::iterator it;
	for (it = mTextMap.begin(); it != mTextMap.end(); it++)
	{
		SAFE_DELETE(it->second);
	}
	mTextMap.clear();
	if (mFTStroker)
	{
		FT_Stroker_Done(mFTStroker);
		mFTStroker = nullptr;
	}

	FT_Done_Face(mFTFace);
	mFTFace = nullptr;
}

FontType Font::GetFontType() const
{
	return mFontType;
}

unsigned int Font::GetFontSize() const
{
	return mFontSize;
}

unsigned int Font::GetFontStyle() const
{
	return mFontStyle;
}

int Font::GetOutlineWidth() const
{
	return mOutlineWidth;
}

TextInfo* Font::GetTextInfo(unsigned long CH)
{
	TextInfo* TI = nullptr;
	if (mTextMap.find(CH) != mTextMap.end())
	{
		TI = mTextMap[CH];
		return TI;
	}
	else
	{
		if (mFTStroker == nullptr && mFontStyle & FSOutline && mOutlineWidth > 0)
		{
			FT_Stroker_New(mFTLibrary, &mFTStroker);
			//  2 * 64 result in 2px outline
			FT_Stroker_Set(mFTStroker, mOutlineWidth * 64, FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);
		}
		TI = new TextInfo;
		TextureUsed* TU = nullptr;
		if (mTextureUesedArray.size() == 0)
		{
			TU = new TextureUsed;
			mTextureUesedArray.push_back(TU);
		}
		else
		{
			TU = mTextureUesedArray[mTextureUesedArray.size() - 1];
		}
		unsigned int GlyphIndex = FT_Get_Char_Index(mFTFace, CH);
		FT_Load_Glyph(mFTFace, GlyphIndex, FT_LOAD_DEFAULT);
		if (mFontStyle & FSItalic)
		{
			float lean = 0.5f;
			FT_Matrix M;
			M.xx = 0x10000L;
			M.xy = FT_Fixed(lean * 0x10000L);
			M.yx = 0;
			M.yy = 0x10000L;
			FT_Outline_Transform(&mFTFace->glyph->outline, &M);
		}
		if (mFontStyle & FSRotate)
		{
			FT_Matrix M;
			float Angle = DegreesToRadians(mRotateDegree);
			M.xx = FT_Fixed(0x10000L * cos(Angle));
			M.xy = FT_Fixed(0x10000L * sin(Angle));
			M.yx = FT_Fixed(0x10000L * (-sin(Angle)));
			M.yy = FT_Fixed(0x10000L * cos(Angle));
			FT_Outline_Transform(&mFTFace->glyph->outline, &M);
		}
		if (mFontStyle & FSBold)
		{
			FT_Outline_EmboldenXY(&mFTFace->glyph->outline, 64 * mBoldWidth, 64 * mBoldWidth);
		}
		if (mFontStyle & FSOutline)
		{
			OutLine::Spans spans;
			OutLine::RenderSpans(mFTLibrary, &mFTFace->glyph->outline, &spans);
			// add outline
			FT_Glyph glyph;
			FT_Get_Glyph(mFTFace->glyph, &glyph);
			FT_Glyph_StrokeBorder(&glyph, mFTStroker, false, true);
// 			FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, nullptr, true);
// 			FT_BitmapGlyph bitmapGlyph = reinterpret_cast<FT_BitmapGlyph>(glyph);

			OutLine::Spans outlineSpans;
			// Render the outline spans to the span list
			FT_Outline *o =
				&reinterpret_cast<FT_OutlineGlyph>(glyph)->outline;
			OutLine::RenderSpans(mFTLibrary, o, &outlineSpans);
			// Clean up afterwards.
			FT_Done_Glyph(glyph);
			// Now we need to put it all together.
			if (!spans.empty())
			{
				// Figure out what the bounding rect is for both the span lists.
				OutLine::Rect rect((float)spans.front().x,
					(float)spans.front().y,
					(float)spans.front().x,
					(float)spans.front().y);
				for (OutLine::Spans::iterator s = spans.begin();
					s != spans.end(); ++s)
				{
					rect.Include(OutLine::Vec2((float)s->x, (float)s->y));
					rect.Include(OutLine::Vec2(float(s->x + s->width - 1), (float)s->y));
				}
				for (OutLine::Spans::iterator s = outlineSpans.begin();
					s != outlineSpans.end(); ++s)
				{
					rect.Include(OutLine::Vec2((float)s->x, (float)s->y));
					rect.Include(OutLine::Vec2(float(s->x + s->width - 1), (float)s->y));
				}
				// Get some metrics of our image.
				int imgWidth = (int)rect.Width(),
					imgHeight = (int)rect.Height(),
					imgSize = imgWidth * imgHeight;

				// Allocate data for our image and clear it out to transparent.
				OutLine::Pixel16 *pxl = new OutLine::Pixel16[imgSize];
				memset(pxl, 0, sizeof(OutLine::Pixel16) * imgSize);

				// Loop over the outline spans and just draw them into the
				// image.
				for (OutLine::Spans::iterator s = outlineSpans.begin();
					s != outlineSpans.end(); ++s)
					for (int w = 0; w < s->width; ++w)
						pxl[(int)((imgHeight - 1 - (s->y - rect.ymin)) * imgWidth
							+ s->x - rect.xmin + w)] =
						OutLine::Pixel16(0, s->coverage);

				// Then loop over the regular glyph spans and blend them into
				// the image.
				for (OutLine::Spans::iterator s = spans.begin();
					s != spans.end(); ++s)
					for (int w = 0; w < s->width; ++w)
					{
						OutLine::Pixel16 &dst =
							pxl[(int)((imgHeight - 1 - (s->y - rect.ymin)) * imgWidth
								+ s->x - rect.xmin + w)];
						OutLine::Pixel16 src = OutLine::Pixel16(255, s->coverage);
						dst.l = (int)(dst.l + ((src.l - dst.l) * src.a) / 255.0f);
						dst.a = MIN(255, dst.a + src.a);
					}
				FT_Bitmap FB;
				FB.rows = imgHeight;
				FB.width = imgWidth;
				FB.buffer = (unsigned char*)pxl;
				if (TU->AddText(*TI, FB, false) == false)
				{
					// image is full, need a new texture
					TU = new TextureUsed;
					mTextureUesedArray.push_back(TU);
					TU->AddText(*TI, FB, false);
				}
				delete[] pxl;
			}
		}
		else
		{
			if (mFTFace->glyph->format != FT_GLYPH_FORMAT_BITMAP)
			{
				FT_Render_Glyph(mFTFace->glyph, FT_RENDER_MODE_NORMAL);
			}
// 			if (mFontStyle & FSBold)
// 			{
// 				FT_Bitmap_Embolden(mFTLibrary, &mFTFace->glyph->bitmap, 64 * mBoldWidth, 64 * mBoldWidth);
// 			}
			if (TU->AddText(*TI, mFTFace->glyph->bitmap) == false)
			{
				// image is full, need a new texture
				TU = new TextureUsed;
				mTextureUesedArray.push_back(TU);
				TU->AddText(*TI, mFTFace->glyph->bitmap);
			}
		}
		// 64 multiple
		TI->width = (mFTFace->glyph->metrics.width >> 6)/* + mOutlineWidth * 2*/;
		TI->height = (mFTFace->glyph->metrics.height >> 6)/* + mOutlineWidth * 2*/;
		TI->horiBearingX = mFTFace->glyph->metrics.horiBearingX >> 6;
		TI->horiBearingY = (mFTFace->glyph->metrics.horiBearingY >> 6)/* + mOutlineWidth*/;
		TI->horiAdvance = (mFTFace->glyph->metrics.horiAdvance >> 6)/* + mOutlineWidth * 2*/;
		TI->vertBearingX = (mFTFace->glyph->metrics.vertBearingX >> 6)/* + mOutlineWidth*/;
		TI->vertBearingY = mFTFace->glyph->metrics.vertBearingY >> 6;
		TI->vertAdvance = (mFTFace->glyph->metrics.vertAdvance >> 6)/* + mOutlineWidth * 2*/;
	}
	mTextMap[CH] = TI;
	return TI;
}

//-----------------------------------------------------------------------

FontManager::FontManager()
{
	mFTLibrary = nullptr;
}

FontManager::~FontManager()
{
	for (size_t i = 0; i < mFontArray.size(); i++)
	{
		SAFE_DELETE(mFontArray[i]);
	}
	mFontArray.clear();
	FT_Done_FreeType(mFTLibrary);
}

Font* FontManager::GetFont(FontType FT, unsigned int FontSize, unsigned int FontStyle/* = FSNormal*/, int OutLineWidth/* = 0*/, int BoldWidth/* = 0*/, float RotateDegree/* = 0*/)
{
	for each(Font* F in mFontArray)
	{
		if (F->GetFontType() == FT && F->GetFontSize() == FontSize && F->GetFontStyle() == FontStyle && F->GetOutlineWidth() == OutLineWidth)
		{
			return F;
		}
	}
	FT_Error      error;
	if (mFTLibrary == nullptr)
	{
		error = FT_Init_FreeType(&mFTLibrary);
		if (mFTLibrary == nullptr)
		{
			return nullptr;
		}
	}
	Font* F = new Font;
	ResourceManager* RM = Scene::GetCurrentScene()->GetResourceManager();
	std::string FontFileName = RM->GetFontFullPath(FT);
	error = FT_New_Face(mFTLibrary, FontFileName.c_str(), 0, &(F->mFTFace));
	if (F->mFTFace == nullptr)
	{
		LogImpl::GetInstance()->LogFormat("Can not loaded font:%s\n", FontFileName.c_str());
	}
	// assume 96 DPI
	error = FT_Set_Char_Size(F->mFTFace, FontSize * 64, FontSize * 64, 96, 96);
	F->mFontSize = FontSize;
	F->mFontType = FT;
	F->mFTLibrary = mFTLibrary;
	F->mFontStyle = FontStyle;
	F->mOutlineWidth = OutLineWidth;
	F->mBoldWidth = BoldWidth;
	F->mRotateDegree = RotateDegree;
	error = FT_Select_Charmap(F->mFTFace, FT_ENCODING_UNICODE);

	mFontArray.push_back(F);
	return F;
}

Font* FontManager::GetStartPoemFont()
{
	return GetFont(YGYXingCao, 64, FSOutline | FSBold, 8, 4);
}

Font* FontManager::GetCommonFont()
{
	return GetFont(MFMengYuan, 16, FSOutline, 2);
}